---
title: 'Factories, Interfaces, and Decorators'
description: 'Understanding core design patterns in FlipEdit'
---

# Factories, Interfaces, and Decorators in FlipEdit

FlipEdit relies on several key design patterns to create a maintainable, extensible video editing application. This document explains how factories, interfaces, and decorators work together to create a clean, flexible architecture.

## Interfaces and Abstractions

Interfaces define contracts that classes must fulfill, enabling polymorphism and flexible component composition. In Dart, interfaces are typically defined as abstract classes.

### Core Interfaces in FlipEdit

FlipEdit defines several key interfaces that form the foundation of its architecture:

```dart
/// Represents any effect that can be applied to media
abstract class IEffect {
  String get id;
  String get name;
  EffectType get type;
  Map<String, dynamic> get parameters;
  int get startFrame;
  int get durationFrames;
  
  /// Process frame data and return modified data
  Map<String, dynamic> process(Map<String, dynamic> frameData);
  
  /// Serialize to JSON
  Map<String, dynamic> toJson();
}

/// Represents a media clip in the timeline
abstract class IClip {
  String get id;
  String get name;
  ClipType get type;
  String get filePath;
  int get startFrame;
  int get durationFrames;
  List<IEffect> get effects;
  Map<String, dynamic> get metadata;
  
  /// Get a processed frame at the given position
  Future<Map<String, dynamic>> getProcessedFrame(int framePosition);
  
  /// Serialize to JSON
  Map<String, dynamic> toJson();
}
```

### Benefits of Interfaces in FlipEdit

Using interfaces provides several key advantages:

1. **Abstraction** - Components only depend on the interface, not specific implementations
2. **Flexibility** - Different implementations can be swapped without changing dependent code
3. **Testability** - Interfaces can be easily mocked for testing
4. **Extension** - New implementations can be added without modifying existing code

For example, FlipEdit can handle different media types by implementing the `IClip` interface:

```dart
class VideoClip implements IClip {
  // Implementation for video clips
}

class AudioClip implements IClip {
  // Implementation for audio clips
}

class ImageSequenceClip implements IClip {
  // Implementation for image sequences
}
```

## The Decorator Pattern

The decorator pattern lets you attach new behaviors to objects by placing them inside wrapper objects that contain these behaviors. This pattern is central to FlipEdit's non-destructive editing approach.

### Decorator Pattern Implementation

FlipEdit uses the decorator pattern extensively for effects:

```dart
/// Base effect implementation
class BaseEffect implements IEffect {
  @override
  final String id;
  @override
  final String name;
  @override
  final EffectType type;
  @override
  final Map<String, dynamic> parameters;
  @override
  final int startFrame;
  @override
  final int durationFrames;
  
  BaseEffect({
    required this.id,
    required this.name,
    required this.type,
    required this.parameters,
    required this.startFrame,
    required this.durationFrames,
  });
  
  @override
  Map<String, dynamic> process(Map<String, dynamic> frameData) {
    // Simple pass-through implementation
    return frameData;
  }
  
  @override
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'type': type.toString(),
      'parameters': parameters,
      'startFrame': startFrame,
      'durationFrames': durationFrames,
    };
  }
}

/// Abstract decorator for effects
abstract class EffectDecorator implements IEffect {
  final IEffect decoratedEffect;
  
  EffectDecorator(this.decoratedEffect);
  
  // Forward properties to decorated effect
  @override
  String get id => decoratedEffect.id;
  
  @override
  String get name => decoratedEffect.name;
  
  @override
  EffectType get type => decoratedEffect.type;
  
  @override
  Map<String, dynamic> get parameters => decoratedEffect.parameters;
  
  @override
  int get startFrame => decoratedEffect.startFrame;
  
  @override
  int get durationFrames => decoratedEffect.durationFrames;
  
  @override
  Map<String, dynamic> process(Map<String, dynamic> frameData) {
    // Apply the wrapped effect first
    final processedData = decoratedEffect.process(frameData);
    // Then apply this decorator's effect
    return applyDecoration(processedData);
  }
  
  @override
  Map<String, dynamic> toJson() {
    final json = decoratedEffect.toJson();
    json['decorator'] = decoratorToJson();
    return json;
  }
  
  // Abstract methods for concrete decorators to implement
  Map<String, dynamic> applyDecoration(Map<String, dynamic> frameData);
  Map<String, dynamic> decoratorToJson();
}
```

### Concrete Decorators

Concrete decorator classes implement specific effects:

```dart
class FilterEffectDecorator extends EffectDecorator {
  final double intensity;
  final Map<String, double> colorAdjustments;
  
  FilterEffectDecorator({
    required IEffect decoratedEffect,
    this.intensity = 1.0,
    this.colorAdjustments = const {},
  }) : super(decoratedEffect);
  
  @override
  Map<String, dynamic> applyDecoration(Map<String, dynamic> frameData) {
    // Apply color adjustments based on intensity
    Map<String, dynamic> result = Map<String, dynamic>.from(frameData);
    
    // Implementation details for applying the filter
    // ...
    
    return result;
  }
  
  @override
  Map<String, dynamic> decoratorToJson() {
    return {
      'type': 'filter',
      'intensity': intensity,
      'colorAdjustments': colorAdjustments,
    };
  }
}

class BlurEffectDecorator extends EffectDecorator {
  final double blurRadius;
  
  BlurEffectDecorator({
    required IEffect decoratedEffect,
    this.blurRadius = 5.0,
  }) : super(decoratedEffect);
  
  @override
  Map<String, dynamic> applyDecoration(Map<String, dynamic> frameData) {
    // Apply blur effect
    Map<String, dynamic> result = Map<String, dynamic>.from(frameData);
    
    // Implementation details for applying blur
    // ...
    
    return result;
  }
  
  @override
  Map<String, dynamic> decoratorToJson() {
    return {
      'type': 'blur',
      'blurRadius': blurRadius,
    };
  }
}
```

### Benefits of Decorators in FlipEdit

The decorator pattern provides several advantages for FlipEdit:

1. **Non-destructive editing** - Original content remains unchanged
2. **Composability** - Effects can be stacked in any order
3. **Extensibility** - New effects can be added without changing existing code
4. **Flexibility** - Effects can be added, removed, or reordered at any time
5. **Performance** - Only the necessary effects are processed

For example, multiple effects can be stacked:

```dart
// Start with a base effect
final baseEffect = BaseEffect(
  id: '1', 
  name: 'Base', 
  type: EffectType.basic,
  parameters: {},
  startFrame: 0,
  durationFrames: 100,
);

// Apply a filter effect
final filteredEffect = FilterEffectDecorator(
  decoratedEffect: baseEffect,
  intensity: 0.8,
  colorAdjustments: {'brightness': 0.1, 'contrast': 0.2},
);

// Then apply a blur effect
final blurredFilteredEffect = BlurEffectDecorator(
  decoratedEffect: filteredEffect,
  blurRadius: 5.0,
);

// Process a frame - effects are applied in sequence
final processedFrame = blurredFilteredEffect.process(originalFrame);
```

## Factory Pattern

The factory pattern centralizes object creation logic, making code more maintainable and encapsulating complex instantiation. FlipEdit uses factories to create clips, effects, and other complex objects.

### Factory Implementation

FlipEdit implements factories for creating complex objects:

```dart
/// Factory for creating effects
class EffectFactory {
  /// Create a base effect with default settings
  static BaseEffect createBaseEffect({
    required String id,
    required String name,
    required EffectType type,
    Map<String, dynamic> parameters = const {},
    int startFrame = 0,
    int durationFrames = 0,
  }) {
    return BaseEffect(
      id: id,
      name: name,
      type: type,
      parameters: parameters,
      startFrame: startFrame,
      durationFrames: durationFrames,
    );
  }
  
  /// Create a filter effect
  static IEffect createFilterEffect({
    required String id,
    required String name,
    int startFrame = 0,
    int durationFrames = 0,
    double intensity = 1.0,
    Map<String, double> colorAdjustments = const {},
  }) {
    final baseEffect = createBaseEffect(
      id: id,
      name: name,
      type: EffectType.filter,
      startFrame: startFrame,
      durationFrames: durationFrames,
    );
    
    return FilterEffectDecorator(
      decoratedEffect: baseEffect,
      intensity: intensity,
      colorAdjustments: colorAdjustments,
    );
  }
  
  /// Create a blur effect
  static IEffect createBlurEffect({
    required String id,
    required String name,
    int startFrame = 0,
    int durationFrames = 0,
    double blurRadius = 5.0,
  }) {
    final baseEffect = createBaseEffect(
      id: id,
      name: name,
      type: EffectType.blur,
      startFrame: startFrame,
      durationFrames: durationFrames,
    );
    
    return BlurEffectDecorator(
      decoratedEffect: baseEffect,
      blurRadius: blurRadius,
    );
  }
  
  /// Create an effect from a serialized representation
  static IEffect createFromJson(Map<String, dynamic> json) {
    // Create the base effect first
    final baseEffect = BaseEffect(
      id: json['id'],
      name: json['name'],
      type: _parseEffectType(json['type']),
      parameters: Map<String, dynamic>.from(json['parameters'] ?? {}),
      startFrame: json['startFrame'] ?? 0,
      durationFrames: json['durationFrames'] ?? 0,
    );
    
    // If there's a decorator, apply it
    if (json.containsKey('decorator')) {
      final decorator = json['decorator'];
      
      switch (decorator['type']) {
        case 'filter':
          return FilterEffectDecorator(
            decoratedEffect: baseEffect,
            intensity: decorator['intensity'] ?? 1.0,
            colorAdjustments: _parseColorAdjustments(decorator['colorAdjustments']),
          );
        case 'blur':
          return BlurEffectDecorator(
            decoratedEffect: baseEffect,
            blurRadius: decorator['blurRadius'] ?? 5.0,
          );
        default:
          return baseEffect;
      }
    }
    
    return baseEffect;
  }
  
  // Helper methods
  static EffectType _parseEffectType(String typeStr) {
    // Convert string to enum
    // ...
    return EffectType.basic;
  }
  
  static Map<String, double> _parseColorAdjustments(dynamic json) {
    // Parse color adjustments
    // ...
    return {};
  }
}
```

### Clip Factory

Similarly, a factory for clips:

```dart
/// Factory for creating clips
class ClipFactory {
  /// Create a basic video clip
  static IClip createVideoClip({
    required String id,
    required String name,
    required String filePath,
    int startFrame = 0,
    int durationFrames = 0,
    List<IEffect> effects = const [],
    Map<String, dynamic> metadata = const {},
  }) {
    return VideoClip(
      id: id,
      name: name,
      filePath: filePath,
      startFrame: startFrame,
      durationFrames: durationFrames,
      effects: effects,
      metadata: metadata,
    );
  }
  
  /// Create a modified speed clip
  static IClip createSpeedModifiedClip({
    required IClip baseClip,
    required double speedFactor,
  }) {
    return SpeedModifiedClip(
      decoratedClip: baseClip,
      speedFactor: speedFactor,
    );
  }
  
  /// Create a clip from JSON
  static IClip createFromJson(Map<String, dynamic> json) {
    // Implementation for deserialization
    // ...
    return VideoClip(...);
  }
}
```

### Benefits of Factories in FlipEdit

Factories provide several advantages:

1. **Centralized Creation Logic** - Creation logic is centralized in one place
2. **Encapsulation** - Complex instantiation details are hidden
3. **Consistency** - Objects are created consistently with proper defaults
4. **Testability** - Factories can be mocked to return test doubles
5. **Serialization Support** - Factories can handle creating objects from serialized data

## Integration of Patterns

In FlipEdit, these patterns work together to create a cohesive architecture:

### Example: Creating a Complex Effect Chain

```dart
// Using factories to create decorated effects
IEffect effectChain = EffectFactory.createBaseEffect(
  id: 'effect-1',
  name: 'My Effect Chain',
  type: EffectType.basic,
);

// Add a filter using a factory
effectChain = EffectFactory.createFilterEffect(
  id: 'effect-2',
  name: 'Color Filter',
  intensity: 0.8,
  colorAdjustments: {'brightness': 0.1},
  // Use the base effect as the decorated effect
  baseEffect: effectChain,
);

// Add a blur using a factory
effectChain = EffectFactory.createBlurEffect(
  id: 'effect-3',
  name: 'Blur Effect',
  blurRadius: 3.0,
  // Use the filter effect as the decorated effect
  baseEffect: effectChain,
);

// Apply the effect chain to a clip
IClip clip = ClipFactory.createVideoClip(
  id: 'clip-1',
  name: 'My Video Clip',
  filePath: '/path/to/video.mp4',
  effects: [effectChain],
);
```

### Example: Processing a Frame Through the Pipeline

```dart
// Get a processed frame from a clip
Future<Map<String, dynamic>> getProcessedFrame(IClip clip, int framePosition) async {
  // First get the raw frame
  Map<String, dynamic> frameData = await loadRawFrame(clip.filePath, framePosition);
  
  // Apply each effect in sequence
  for (final effect in clip.effects) {
    if (isEffectActiveAtFrame(effect, framePosition)) {
      frameData = effect.process(frameData);
    }
  }
  
  return frameData;
}

bool isEffectActiveAtFrame(IEffect effect, int framePosition) {
  return effect.startFrame <= framePosition && 
         effect.startFrame + effect.durationFrames > framePosition;
}
```

## VS Code-inspired Approach

This architecture is inspired by VS Code's approach, but adapted for Flutter. Here's how they compare:

### VS Code's Extension Model (TypeScript)

```typescript
// VS Code extension interface
export interface IExtension {
  readonly id: string;
  activate(context: ExtensionContext): Promise<void>;
  deactivate?(): void;
}

// VS Code decorator pattern for commands
export class CommandDecorator implements Command {
  constructor(private readonly decoratedCommand: Command) {}
  
  get id(): string { return this.decoratedCommand.id; }
  
  async execute(...args: any[]): Promise<any> {
    // Do something before
    const result = await this.decoratedCommand.execute(...args);
    // Do something after
    return result;
  }
}

// VS Code factory for creating editors
export class EditorFactory {
  static createTextEditor(document: TextDocument): IEditor {
    return new TextEditor(document);
  }
  
  static createDiffEditor(original: TextDocument, modified: TextDocument): IEditor {
    return new DiffEditor(original, modified);
  }
}
```

### FlipEdit's Flutter Adaptation

```dart
// FlipEdit extension interface
abstract class IExtension {
  String get id;
  Future<void> activate(ExtensionContext context);
  Future<void> deactivate();
}

// FlipEdit decorator pattern for effects
class EffectDecorator implements IEffect {
  final IEffect decoratedEffect;
  
  EffectDecorator(this.decoratedEffect);
  
  // Implementation shown earlier
}

// FlipEdit factory for creating clips
class ClipFactory {
  static IClip createVideoClip({...}) {
    return VideoClip(...);
  }
}
```

The key differences are:
1. **Language** - TypeScript vs Dart
2. **UI Framework** - DOM vs Flutter widgets
3. **Async Model** - Promises vs Futures
4. **Implementation Details** - Adapted for each platform's strengths

## Applying Patterns in ViewModels

ViewModels in FlipEdit also use these patterns to maintain clean, testable code:

```dart
class EffectsViewModel extends ChangeNotifier {
  final List<IEffect> _effects = [];
  IEffect? _selectedEffect;
  
  // Read-only views of the data
  List<IEffect> get effects => List.unmodifiable(_effects);
  IEffect? get selectedEffect => _selectedEffect;
  
  // Factory method within ViewModel
  Future<void> createEffect(EffectType type, {
    required String name,
    Map<String, dynamic> parameters = const {},
  }) async {
    final effectId = _generateUniqueId();
    
    IEffect newEffect;
    
    switch (type) {
      case EffectType.filter:
        newEffect = EffectFactory.createFilterEffect(
          id: effectId,
          name: name,
          intensity: parameters['intensity'] ?? 1.0,
          colorAdjustments: parameters['colorAdjustments'] ?? {},
        );
        break;
      case EffectType.blur:
        newEffect = EffectFactory.createBlurEffect(
          id: effectId,
          name: name,
          blurRadius: parameters['blurRadius'] ?? 5.0,
        );
        break;
      default:
        newEffect = EffectFactory.createBaseEffect(
          id: effectId,
          name: name,
          type: type,
          parameters: parameters,
        );
    }
    
    _effects.add(newEffect);
    _selectedEffect = newEffect;
    notifyListeners();
  }
  
  // Other methods...
}
```

## Next Steps

- [Decorator Pattern](./decorator-pattern.mdx) - Learn more about the decorator pattern in FlipEdit
- [Effect Pipeline](./effect-pipeline.mdx) - Understand the effect processing pipeline
- [MVVM Architecture](./mvvm.mdx) - See how these patterns fit into the overall MVVM architecture
- [Extension System](./extension-system.mdx) - Learn about FlipEdit's extension system
