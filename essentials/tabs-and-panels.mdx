---
title: 'Tabs and Panels'
description: 'Understanding how tabs and panels are managed in the FlipEdit interface'
icon: 'window-maximize'
---

# Tabs and Panels Management

FlipEdit uses the docking package to manage tabs and panels in the editor interface. This document explains how the interface components are organized, how tabs are stored, opened, closed, and persisted within the application.

## Overview

The FlipEdit interface is organized into panels that can be arranged in various layouts. The main panels include:

- **Preview Panel**: For viewing content
- **Timeline Panel**: For editing time-based media
- **Inspector Panel**: For adjusting properties and settings

These panels can be toggled on or off, resized, and rearranged according to user preference.

## Architecture

### Storage of Opened Tabs

The `EditorViewModel` class is responsible for maintaining the state of the editor layout, including which panels are visible. The key components of this system include:

#### Panel Visibility State

```dart
// State flags for panel visibility
final ValueNotifier<bool> isTimelineVisibleNotifier = ValueNotifier<bool>(true);
final ValueNotifier<bool> isInspectorVisibleNotifier = ValueNotifier<bool>(true);
```

#### Layout Structure

```dart
final ValueNotifier<DockingLayout?> layoutNotifier = ValueNotifier<DockingLayout?>(null);
```

#### Layout Structure Key

The `layoutStructureKey` property represents the current configuration of visible panels as a string:

```dart
String get layoutStructureKey {
  // Generate a simple string based on visible panels
  final parts = ['preview']; // Preview is always there
  if (isTimelineVisible) parts.add('timeline');
  if (isInspectorVisible) parts.add('inspector');
  return parts.join('_');
}
```

This key (e.g., "preview_timeline_inspector") is used to identify different layout configurations.

## Panel Management

### Opening Tabs

Tabs are opened through the following mechanisms:

#### Initial Layout

When the editor is first loaded, the `initializePanelLayout()` method is called to set up the default layout:

```dart
void initializePanelLayout() {
  final previewItem = DockingItem(id: 'preview', name: 'Preview', ...);
  final timelineItem = DockingItem(id: 'timeline', name: 'Timeline', ...);
  final inspectorItem = DockingItem(id: 'inspector', name: 'Inspector', ...);
  
  layout = DockingLayout(
    root: DockingRow([
      DockingColumn([previewItem, timelineItem]),
      inspectorItem
    ])
  );
}
```

#### Toggling Panels

Panels can be toggled on and off using the toggle methods:

```dart
void toggleTimeline() {
  isTimelineVisible = !isTimelineVisible;
}

void toggleInspector() {
  isInspectorVisible = !isInspectorVisible;
}
```

These methods are typically called from the application menu:

```dart
PlatformMenuItem(
  label: isTimelineVisible ? 'âœ“ Timeline' : '  Timeline',
  shortcut: const SingleActivator(LogicalKeyboardKey.keyT, meta: true),
  onSelected: () {
    di<EditorViewModel>().toggleTimeline();
  },
)
```

### Closing Tabs

Tabs can be closed in two ways:

#### User-Initiated Close

When a user closes a tab using the UI, the `onItemClose` callback is triggered:

```dart
Docking(
  layout: layout,
  onItemClose: _handlePanelClosed,
)
```

This calls the handler method:

```dart
void _handlePanelClosed(DockingItem item) {
  if (item.id == 'inspector') {
    di<EditorViewModel>().markInspectorClosed();
  } else if (item.id == 'timeline') {
    di<EditorViewModel>().markTimelineClosed();
  }
}
```

#### Programmatic Close

Panels can be closed programmatically by setting their visibility flag to false:

```dart
void markInspectorClosed() {
  if (isInspectorVisible) {
    isInspectorVisible = false;
  }
}

void markTimelineClosed() {
  if (isTimelineVisible) {
    isTimelineVisible = false;
  }
}
```

## Layout Updates

When panel visibility changes, the layout is automatically updated through the `_updateLayout()` method:

```dart
set isTimelineVisible(bool value) {
  if (isTimelineVisibleNotifier.value == value) return;
  isTimelineVisibleNotifier.value = value;
  _updateLayout();
}
```

The `_updateLayout()` method calls `_buildLayout()`, which reconstructs the entire layout based on the current visibility settings:

```dart
void _buildLayout() {
  final items = <DockingItem>[];
  
  // Always add the preview
  items.add(_buildPreviewItem());
  
  // Add timeline if visible
  if (isTimelineVisible) {
    items.add(_buildTimelineItem());
  }
  
  // Add inspector if visible
  if (isInspectorVisible) {
    items.add(_buildInspectorItem());
  }
  
  // Create a layout with the items based on how many are visible
  // ...
}
```

## Integration with State Management

The application uses the `watch_it` package for reactive state management. This allows UI components to automatically update when the tab state changes:

```dart
final selectedExtension = watchValue((EditorViewModel vm) => vm.selectedExtensionNotifier);
final layout = watchValue((EditorViewModel vm) => vm.layoutNotifier);
```

## Current Limitations and Future Improvements

Currently, the tab state is not explicitly persisted between application sessions. To implement persistence, the following would be needed:

1. Save the layout state when the application closes or when changes are made
2. Restore the layout state when the application starts

This could be implemented by:

- Adding methods to serialize the layout state to JSON
- Storing this JSON in local storage (e.g., using the `shared_preferences` package)
- Loading and applying the saved state on application startup

## Recommendations for Enhancement

1. **Persistence**: Add state persistence to remember the user's preferred layout between sessions
2. **Custom Layouts**: Allow users to save and load custom layouts
3. **Drag and Drop**: Enhance the docking system to allow more flexible rearrangement of panels
4. **Panel State**: Store additional state for each panel (e.g., scroll position, selected items)

## Adding New Panel Types

To add a new tab type to the system:

1. Create a new panel widget
2. Add a visibility flag in `EditorViewModel`
3. Create a builder method in `EditorViewModel` (e.g., `_buildNewPanelItem()`)
4. Update the `_buildLayout()` method to include the new panel
5. Add toggle methods and UI controls for the new panel

This approach ensures that new panels integrate seamlessly with the existing tab management system.
